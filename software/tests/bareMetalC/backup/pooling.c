#include <stdio.h>
#include "include/encoding.h"
#include "include/ISA.h"

#define TYPE int
#define IH 55
#define IW 55
#define OH 27
#define OW 27
#define SH 2
#define SW 2
#define PH 3
#define PW 3
#define IC 9

TYPE A[IC][IH + 1][IW] __attribute__((aligned(8)));
TYPE B[IC][OH + 1][OW] __attribute__((aligned(8)));
TYPE R[IC][OH][OW] __attribute__((aligned(8)));

void init() {
    for (int ic = 0; ic < IC; ic ++){
        for (int h = 0; h < IH; h ++) {
            for (int w = 0; w < IW; w++) {
                A[ic][h][w] = ic + h + w; 
            }
        }
    }
}

void work () {
    for (int ic = 0; ic < IC; ic ++){
        for (int h = 0; h < OH; h ++){
            for (int w = 0; w < OW; w ++){
                for (int ph = 0; ph < PH; ph ++){
                    for (int pw = 0; pw < PW; pw ++){
                        R[ic][h][w] = (R[ic][h][w] > A[ic][h * SH + ph][w * SW + pw]) ? R[ic][h][w] : A[ic][h * SH + ph][w * SW + pw];
                    }
                }
            }
        }
    }
}

void cgra_execute(void** din_addr, void** dout_addr)
{
	volatile unsigned short cin[124][3] __attribute__((aligned(8))) = {
		{0x2000, 0x1800, 0x0008},
		{0x0000, 0x0030, 0x0009},
		{0x6001, 0x0203, 0x000a},
		{0x06c0, 0x022c, 0x000b},
		{0x0002, 0x0000, 0x000c},
		{0x5000, 0x1800, 0x0010},
		{0x1a80, 0x0030, 0x0011},
		{0x7f92, 0x9403, 0x0012},
		{0x06ff, 0x0004, 0x0013},
		{0x3000, 0x1800, 0x0018},
		{0x0000, 0x0030, 0x0019},
		{0x6001, 0x0203, 0x001a},
		{0x06c0, 0x022c, 0x001b},
		{0x0000, 0x0000, 0x001c},
		{0x4000, 0x1800, 0x0020},
		{0x1a80, 0x0030, 0x0021},
		{0x7f92, 0x9403, 0x0022},
		{0x06ff, 0x0004, 0x0023},
		{0x3000, 0x1800, 0x0028},
		{0x0000, 0x0030, 0x0029},
		{0x6001, 0x0203, 0x002a},
		{0x06c0, 0x0224, 0x002b},
		{0x0002, 0x0000, 0x002c},
		{0x4000, 0x1800, 0x0030},
		{0x1a80, 0x0030, 0x0031},
		{0x7f92, 0x9403, 0x0032},
		{0x06ff, 0x0004, 0x0033},
		{0x2000, 0x1800, 0x0038},
		{0x0000, 0x0030, 0x0039},
		{0x6001, 0x0203, 0x003a},
		{0x06c0, 0x0224, 0x003b},
		{0x0002, 0x0000, 0x003c},
		{0x5000, 0x1800, 0x0040},
		{0x1a80, 0x0030, 0x0041},
		{0x7f92, 0x9403, 0x0042},
		{0x06ff, 0x0004, 0x0043},
		{0x3000, 0x1800, 0x0048},
		{0x0000, 0x0030, 0x0049},
		{0x6001, 0x0203, 0x004a},
		{0x06c0, 0x0224, 0x004b},
		{0x0000, 0x0000, 0x004c},
		{0x0003, 0x0004, 0x0060},
		{0x0020, 0x0000, 0x0068},
		{0x0000, 0x0000, 0x0078},
		{0x0001, 0x0000, 0x0080},
		{0x0000, 0x0000, 0x0088},
		{0x0101, 0x0000, 0x0090},
		{0x0010, 0x0000, 0x0098},
		{0x2015, 0x0000, 0x00a9},
		{0x0000, 0xc004, 0x00aa},
		{0x0090, 0x02d9, 0x00ab},
		{0x1015, 0x0000, 0x00c9},
		{0x0000, 0xc004, 0x00ca},
		{0x0090, 0x02d9, 0x00cb},
		{0x1015, 0x0000, 0x00d9},
		{0x0000, 0xc004, 0x00da},
		{0x0090, 0x02d9, 0x00db},
		{0x1015, 0x0000, 0x00e1},
		{0x0000, 0xc004, 0x00e2},
		{0x0090, 0x02d9, 0x00e3},
		{0x0000, 0x0020, 0x0100},
		{0x0000, 0x0020, 0x01a0},
		{0x0000, 0x0000, 0x0240},
		{0x3015, 0x0000, 0x0291},
		{0x0000, 0xc004, 0x0292},
		{0x0090, 0x02d9, 0x0293},
		{0x3015, 0x0000, 0x0299},
		{0x0000, 0xc004, 0x029a},
		{0x0090, 0x02d9, 0x029b},
		{0x3015, 0x0000, 0x02a9},
		{0x0000, 0xc004, 0x02aa},
		{0x0090, 0x02d9, 0x02ab},
		{0x3015, 0x0000, 0x02b9},
		{0x0000, 0xc004, 0x02ba},
		{0x0090, 0x02d9, 0x02bb},
		{0x3015, 0x0000, 0x02c1},
		{0x0000, 0xc004, 0x02c2},
		{0x0090, 0x02d9, 0x02c3},
		{0x0010, 0x0000, 0x02e0},
		{0x0110, 0x0000, 0x02e8},
		{0x0110, 0x0000, 0x02f8},
		{0x0010, 0x0000, 0x0308},
		{0x0110, 0x0000, 0x0310},
		{0x0200, 0x0000, 0x0318},
		{0x5000, 0x1800, 0x0328},
		{0x1a80, 0x0030, 0x0329},
		{0x7f92, 0x9403, 0x032a},
		{0x06ff, 0x0004, 0x032b},
		{0x4000, 0x1800, 0x0330},
		{0x1a80, 0x0030, 0x0331},
		{0x7f92, 0x9403, 0x0332},
		{0x06ff, 0x0004, 0x0333},
		{0x2000, 0x1800, 0x0338},
		{0x0000, 0x0030, 0x0339},
		{0x6001, 0x0203, 0x033a},
		{0x06c0, 0x0224, 0x033b},
		{0x0000, 0x0000, 0x033c},
		{0x4000, 0x1800, 0x0340},
		{0x1a80, 0x0030, 0x0341},
		{0x7f92, 0x9403, 0x0342},
		{0x06ff, 0x0004, 0x0343},
		{0x3000, 0x1800, 0x0348},
		{0x0000, 0x0030, 0x0349},
		{0x6001, 0x0203, 0x034a},
		{0x06c0, 0x0224, 0x034b},
		{0x0000, 0x0000, 0x034c},
		{0x6000, 0x1800, 0x0350},
		{0x1a80, 0x0030, 0x0351},
		{0x7f92, 0x9403, 0x0352},
		{0x06ff, 0x0004, 0x0353},
		{0x5000, 0x1800, 0x0358},
		{0x1a80, 0x0030, 0x0359},
		{0x7f92, 0x9403, 0x035a},
		{0x06ff, 0x0004, 0x035b},
		{0x0000, 0x1800, 0x0360},
		{0x0000, 0x0030, 0x0361},
		{0x6001, 0x0203, 0x0362},
		{0x06c0, 0x0224, 0x0363},
		{0x0000, 0x0000, 0x0364},
		{0x1000, 0x1800, 0x0368},
		{0x0000, 0x0030, 0x0369},
		{0x6001, 0x0203, 0x036a},
		{0x06c0, 0x022c, 0x036b},
		{0x0000, 0x0000, 0x036c},
	};

	load_cfg((void*)cin, 0x48000, 744, 1);
	load_data(din_addr[0], 0x30000, 12100, 0, 1);
	load_data(din_addr[1], 0x10000, 12100, 0, 1);
	load_data(din_addr[2], 0x0, 12100, 0, 1);
	load_data(din_addr[3], 0x20000, 12100, 0, 1);
	load_data(din_addr[4], 0x24000, 12100, 0, 1);
	load_data(din_addr[5], 0x34000, 12100, 0, 1);
	load_data(din_addr[6], 0x4000, 12100, 0, 1);
	load_data(din_addr[7], 0x14000, 12100, 0, 1);
	load_data(din_addr[8], 0x38000, 12100, 0, 1);
	config(0x0, 124, 1);
	execute(0x3ffff, 1);
	store(dout_addr[0], 0x3c000, 2916, 1);
	store(dout_addr[1], 0x18000, 2916, 1);
	store(dout_addr[2], 0x1c000, 2916, 1);
	store(dout_addr[3], 0x28000, 2916, 1);
	store(dout_addr[4], 0x8000, 2916, 1);
	store(dout_addr[5], 0x40000, 2916, 1);
	store(dout_addr[6], 0xc000, 2916, 1);
	store(dout_addr[7], 0x2c000, 2916, 1);
	store(dout_addr[8], 0x44000, 2916, 1);
}

void check(){
    for (int ic = 0; ic < IC; ic ++){
        for (int h = 0; h < PH; h ++){
            for (int w = 0; w < PW; w ++){
                if(R[ic][h][w] != B[ic][h][w])
                    printf("Wrong in the location (%d, %d, %d): The right number is: %d, The wrong number is: %d\n", ic, h, w, R[ic][h][w], B[ic][h][w]);
            }
        }
    }
}
int main(){
    init();
    printf("Initilization finished!\n");

    long long unsigned start, end;

    start = rdcycle();
    void* cgra_din_addr[9] = {A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[8]};
    void* cgra_dout_addr[9] = {B[0], B[1], B[2], B[3], B[4], B[5], B[6], B[7], B[8]};
    cgra_execute(cgra_din_addr, cgra_dout_addr);
    volatile int result = fence(1);
    end = rdcycle();
    printf("It takes %d cycles for CGRA to finish the task.(%d)\n", end - start, result);

    start = rdcycle();
    work();
    end = rdcycle();
    printf("It takes %d cycles for CPU to finish the task.\n", end - start);

    check();
    printf("done!\n");
    return 0;
}